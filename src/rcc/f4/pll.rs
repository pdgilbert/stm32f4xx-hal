use super::CFGR;
use crate::pac::RCC;

#[cfg_attr(feature = "defmt", derive(defmt::Format))]
#[derive(Copy, Clone, PartialEq, Eq, Debug)]
pub struct PllSetup {
    pub use_pll: bool,
    pub pllsysclk: Option<u32>,
    pub pll48clk: Option<u32>,

    #[cfg(not(feature = "gpio-f410"))]
    pub use_i2spll: bool,
    pub(super) i2s: super::RealI2sClocks,

    #[cfg(feature = "sai")]
    #[cfg(not(feature = "gpio-f413"))]
    pub use_saipll: bool,
    #[cfg(feature = "sai")]
    pub(super) sai: super::RealSaiClocks,
}

impl PllSetup {
    #[cfg(feature = "gpio-f410")]
    #[inline(always)]
    pub fn from_cfgr(cfgr: &CFGR, pllsrcclk: u32, pllsysclk: Option<u32>) -> Self {
        let i2s_clocks = cfgr.i2s_clocks();

        let (main_pll, plli2sclk) = if let Some(i2s_clk) = i2s_clocks.pll_i2s_clk {
            // The I2S frequency is generated by the main PLL. The frequency needs to be accurate,
            // so we need an expensive full PLL configuration search.
            MainPll::setup_with_i2s(
                pllsrcclk,
                cfgr.hse.is_some(),
                pllsysclk,
                cfgr.pll48clk,
                i2s_clk,
            )
        } else {
            (
                MainPll::fast_setup(pllsrcclk, cfgr.hse.is_some(), pllsysclk, cfgr.pll48clk),
                None,
            )
        };

        Self {
            use_pll: main_pll.use_pll(),
            pllsysclk: main_pll.pllsysclk(),
            pll48clk: main_pll.pll48clk(),

            i2s: i2s_clocks.real(plli2sclk, cfgr.i2s_ckin),
        }
    }

    #[cfg(feature = "gpio-f413")]
    #[inline(always)]
    pub fn from_cfgr(cfgr: &CFGR, pllsrcclk: u32, pllsysclk: Option<u32>) -> Self {
        let rcc = unsafe { &*RCC::ptr() };

        let i2s_clocks = cfgr.i2s_clocks();
        let sai_clocks = cfgr.sai_clocks();

        let main_pll = MainPll::fast_setup(pllsrcclk, cfgr.hse.is_some(), pllsysclk, cfgr.pll48clk);

        let (i2s_pll, real_sai_clk) = if let Some(i2s_clk) = i2s_clocks.pll_i2s_clk {
            // Currently, we only support generating SAI/PLL clocks with the I2S PLL. This is only
            // really usable when the frequencies are identical or the I2S frequency is a multiple of
            // the SAI frequency. Therefore, we just optimize the PLL for the I2S frequency and then
            // derive the SAI frequency from the I2S frequency.
            let i2s_pll = I2sPll::setup(pllsrcclk, Some(i2s_clk));

            if let Some(sai_clk) = sai_clocks.pll_sai_clk {
                let div = crate::min_u32(
                    if let I2sPll::Used { plli2sclk, .. } = i2s_pll {
                        crate::max_u32((plli2sclk + (sai_clk >> 1)) / sai_clk, 1)
                    } else {
                        panic!()
                    },
                    31,
                );
                rcc.dckcfgr().modify(|_, w| w.plli2sdivr().set(div as u8));
                let real_sai_clk = sai_clk / div;
                (i2s_pll, Some(real_sai_clk))
            } else {
                (i2s_pll, None)
            }
        } else if let Some(pll_sai_clk) = sai_clocks.pll_sai_clk {
            // We try all divider values to get the best approximation of the requested frequency.
            // NOTE: STM32F413/423 have a different divider range than other models!
            let (i2s_pll, real_sai_clk, div) = (1..31)
                .map(|div| {
                    let i2s_pll = I2sPll::setup(pllsrcclk, Some(pll_sai_clk * div));
                    let real_clk = if let I2sPll::Used { plli2sclk, .. } = i2s_pll {
                        plli2sclk / div
                    } else {
                        panic!()
                    };
                    (i2s_pll, real_clk, div)
                })
                .min_by_key(|(_, real_clk, _)| (*real_clk as i32 - pll_sai_clk as i32).abs())
                .unwrap();
            rcc.dckcfgr().modify(|_, w| w.plli2sdivr().set(div as u8));
            (i2s_pll, Some(real_sai_clk))
        } else {
            (I2sPll::Unused, None)
        };

        Self {
            use_pll: main_pll.use_pll(),
            pllsysclk: main_pll.pllsysclk(),
            pll48clk: main_pll.pll48clk(),

            use_i2spll: i2s_pll.use_pll(),
            i2s: i2s_clocks.real(i2s_pll.plli2sclk(), cfgr.i2s_ckin),

            sai: sai_clocks.real(real_sai_clk, cfgr.i2s_ckin),
        }
    }

    #[cfg(not(any(feature = "gpio-f410", feature = "gpio-f413")))]
    #[inline(always)]
    pub fn from_cfgr(cfgr: &CFGR, pllsrcclk: u32, pllsysclk: Option<u32>) -> Self {
        let i2s_clocks = cfgr.i2s_clocks();
        #[cfg(feature = "sai")]
        let sai_clocks = cfgr.sai_clocks();

        // All PLLs are completely independent.
        let main_pll = MainPll::fast_setup(pllsrcclk, cfgr.hse.is_some(), pllsysclk, cfgr.pll48clk);

        #[cfg(not(feature = "rcc_shared_m"))]
        let i2s_pll = I2sPll::setup(pllsrcclk, i2s_clocks.pll_i2s_clk);
        #[cfg(feature = "rcc_shared_m")]
        // We have separate PLLs, but they share the "M" divider.
        let i2s_pll = I2sPll::setup_shared_m(pllsrcclk, main_pll.m(), i2s_clocks.pll_i2s_clk);

        #[cfg(feature = "sai")]
        #[cfg(not(feature = "rcc_shared_m"))]
        let sai_pll = SaiPll::setup(pllsrcclk, sai_clocks.pll_sai_clk);
        #[cfg(feature = "sai")]
        #[cfg(feature = "rcc_shared_m")]
        let sai_pll = SaiPll::setup_shared_m(
            pllsrcclk,
            main_pll.m().or(i2s_pll.m()),
            sai_clocks.pll_sai_clk,
        );

        Self {
            use_pll: main_pll.use_pll(),
            pllsysclk: main_pll.pllsysclk(),
            pll48clk: main_pll.pll48clk(),

            use_i2spll: i2s_pll.use_pll(),
            i2s: i2s_clocks.real(i2s_pll.plli2sclk(), cfgr.i2s_ckin),

            #[cfg(feature = "sai")]
            use_saipll: sai_pll.use_pll(),
            #[cfg(feature = "sai")]
            sai: sai_clocks.real(sai_pll.sai_clk(), cfgr.i2s_ckin),
        }
    }
}

#[derive(Clone, Copy)]
pub enum MainPll {
    Used {
        pllsysclk: Option<u32>,
        pll48clk: Option<u32>,
        /// "M" divisor, required for the other PLLs on some MCUs.
        #[allow(unused)]
        m: u32,
    },
    Unused,
}

impl MainPll {
    fn use_pll(&self) -> bool {
        matches!(self, Self::Used { .. })
    }
    fn pllsysclk(&self) -> Option<u32> {
        match self {
            Self::Used { pllsysclk, .. } => *pllsysclk,
            Self::Unused => None,
        }
    }
    fn pll48clk(&self) -> Option<u32> {
        match self {
            Self::Used { pll48clk, .. } => *pll48clk,
            Self::Unused => None,
        }
    }
    #[allow(unused)]
    fn m(&self) -> Option<u32> {
        if let Self::Used { m, .. } = self {
            Some(*m)
        } else {
            None
        }
    }

    fn fast_setup(pllsrcclk: u32, use_hse: bool, pllsysclk: Option<u32>, pll48clk: bool) -> Self {
        let sysclk = pllsysclk.unwrap_or(pllsrcclk);
        if pllsysclk.is_none() && !pll48clk {
            // Even if we do not use the main PLL, we still need to set the PLL source as that setting
            // applies to the I2S and SAI PLLs as well.
            unsafe { &*RCC::ptr() }
                .pllcfgr()
                .write(|w| w.pllsrc().bit(use_hse));

            return Self::Unused;
        }
        // Input divisor from PLL source clock, must result to frequency in
        // the range from 1 to 2 MHz
        let pllm_min = (pllsrcclk + 1_999_999) / 2_000_000;
        let pllm_max = pllsrcclk / 1_000_000;

        // Sysclk output divisor must be one of 2, 4, 6 or 8
        let sysclk_div = crate::min_u32(8, (432_000_000 / sysclk) & !1);

        let target_freq = if pll48clk {
            48_000_000
        } else {
            sysclk * sysclk_div
        };

        // Find the lowest pllm value that minimize the difference between
        // target frequency and the real vco_out frequency.
        let pllm = (pllm_min..=pllm_max)
            .min_by_key(|pllm| {
                let vco_in = pllsrcclk / pllm;
                let plln = target_freq / vco_in;
                target_freq - vco_in * plln
            })
            .unwrap();

        let vco_in = pllsrcclk / pllm;
        assert!((1_000_000..=2_000_000).contains(&vco_in));

        // Main scaler, must result in >= 100MHz (>= 192MHz for F401)
        // and <= 432MHz, min 50, max 432
        let plln = if pll48clk {
            // try the different valid pllq according to the valid
            // main scaller values, and take the best
            let pllq = (4..=9)
                .min_by_key(|pllq| {
                    let plln = 48_000_000 * pllq / vco_in;
                    let pll48_diff = 48_000_000 - vco_in * plln / pllq;
                    let sysclk_diff = (sysclk as i32 - (vco_in * plln / sysclk_div) as i32).abs();
                    (pll48_diff, sysclk_diff)
                })
                .unwrap();
            48_000_000 * pllq / vco_in
        } else {
            sysclk * sysclk_div / vco_in
        };
        let pllp = (sysclk_div / 2) - 1;

        let pllq = (vco_in * plln + 47_999_999) / 48_000_000;
        let real_pll48clk = vco_in * plln / pllq;

        unsafe { &*RCC::ptr() }.pllcfgr().write(|w| unsafe {
            w.pllm().bits(pllm as u8);
            w.plln().bits(plln as u16);
            w.pllp().bits(pllp as u8);
            w.pllq().bits(pllq as u8);
            w.pllsrc().bit(use_hse)
        });

        let real_pllsysclk = vco_in * plln / sysclk_div;

        Self::Used {
            pllsysclk: Some(real_pllsysclk),
            pll48clk: pll48clk.then_some(real_pll48clk),
            m: pllm,
        }
    }
}

#[cfg(feature = "gpio-f410")]
impl MainPll {
    fn setup_with_i2s(
        pllsrcclk: u32,
        use_hse: bool,
        pllsysclk: Option<u32>,
        pll48clk: bool,
        plli2sclk: u32,
    ) -> (Self, Option<u32>) {
        use super::{SYSCLK_MAX, SYSCLK_MIN};

        // Input divisor from PLL source clock, must result to frequency in
        // the range from 1 to 2 MHz
        let pllm_min = (pllsrcclk + 1_999_999) / 2_000_000;
        let pllm_max = pllsrcclk / 1_000_000;

        let (pllm, plln, pllp, pllq, pllr, _) = (pllm_min..=pllm_max)
            .filter_map(|m| {
                let vco_in = pllsrcclk / m;

                // The VCO output must be within 100 and 432 MHz.
                let plln_min = (100_000_000 + vco_in - 1) / vco_in;
                let plln_max = 432_000_000 / vco_in;

                (plln_min..=plln_max)
                    .filter_map(|n| {
                        let vco_out = vco_in * n;

                        // The "P" divider value must be even (2, 4, 6, 8).
                        let p = if let Some(pllsysclk) = pllsysclk {
                            let (p, p_output, p_error) = Self::best_divider(
                                vco_out,
                                SYSCLK_MIN * 2,
                                pllsysclk * 2,
                                SYSCLK_MAX * 2,
                                1,
                                4,
                            )?;
                            Some((p * 2, p_output / 2, p_error / 2))
                        } else {
                            None
                        };

                        // The 48 MHz clock must be accurate within 0.25% for USB.
                        let q = pll48clk.then_some(Self::best_divider(
                            vco_out, 47_880_000, 48_000_000, 48_120_000, 2, 15,
                        )?);

                        // We do not set any accuracy requirements for I2S, as on F410 this frequency is
                        // provided on a best-effort basis.
                        // TODO: What is the maximum valid input frequency for I2S?
                        let r = Self::best_divider(vco_out, 0, plli2sclk, u32::MAX, 2, 15)?;

                        let error = p.map(|(_, _, error)| error).unwrap_or(0)
                            + p.map(|(_, _, error)| error).unwrap_or(0)
                            + r.2;

                        Some((m, n, p.map(|p| p.0), q.map(|q| q.0), r.0, error))
                    })
                    .min_by_key(|(_, _, _, _, _, error)| *error)
            })
            .min_by_key(|(_, _, _, _, _, error)| *error)
            .expect("could not find a valid main PLL configuration");

        unsafe { &*RCC::ptr() }.pllcfgr().write(|w| unsafe {
            w.pllm().bits(pllm as u8);
            w.plln().bits(plln as u16);
            if let Some(pllp) = pllp {
                w.pllp().bits(pllp as u8 / 2 - 1);
            }
            if let Some(pllq) = pllq {
                w.pllq().bits(pllq as u8);
            }
            w.pllr().bits(pllr as u8);
            w.pllsrc().bit(use_hse)
        });

        let real_pllsysclk = pllp.map(|pllp| pllsrcclk / pllm * plln / pllp);
        let real_pll48clk = pllq.map(|pllq| pllsrcclk / pllm * plln / pllq);

        (
            Self::Used {
                pllsysclk: real_pllsysclk,
                pll48clk: real_pll48clk,
                m: pllm,
            },
            // TODO: check this
            None,
        )
    }

    const fn best_divider(
        vco_out: u32,
        min: u32,
        target: u32,
        max: u32,
        min_div: u32,
        max_div: u32,
    ) -> Option<(u32, u32, u32)> {
        let div = (vco_out + target / 2) / target;
        let min_div = crate::max_u32(
            min_div,
            if max != 0 {
                (vco_out + max - 1) / max
            } else {
                0
            },
        );
        let max_div = crate::min_u32(max_div, if min != 0 { vco_out / min } else { u32::MAX });
        if min_div > max_div {
            return None;
        }
        let div = crate::min_u32(crate::max_u32(div, min_div), max_div);
        let output = vco_out / div;
        let error = (output as i32 - target as i32).unsigned_abs();
        Some((div, output, error))
    }
}

#[cfg(not(feature = "gpio-f410"))]
#[derive(Clone, Copy)]
pub enum I2sPll {
    Used {
        /// "M" divisor, required for the other PLLs on some MCUs.
        m: u32,
        /// PLL I2S clock output.
        plli2sclk: u32,
    },
    Unused,
}

#[cfg(not(feature = "gpio-f410"))]
impl I2sPll {
    fn use_pll(&self) -> bool {
        matches!(self, Self::Used { .. })
    }

    #[allow(unused)]
    fn m(&self) -> Option<u32> {
        if let Self::Used { m, .. } = self {
            Some(*m)
        } else {
            None
        }
    }

    fn plli2sclk(&self) -> Option<u32> {
        if let Self::Used { plli2sclk, .. } = self {
            Some(*plli2sclk)
        } else {
            None
        }
    }

    fn setup(pllsrcclk: u32, plli2sclk: Option<u32>) -> Self {
        let Some(target) = plli2sclk else {
            return Self::Unused;
        };
        // Input divisor from PLL source clock, must result to frequency in
        // the range from 1 to 2 MHz
        let pllm_min = (pllsrcclk + 1_999_999) / 2_000_000;
        let pllm_max = pllsrcclk / 1_000_000;
        let (pll, config, _) = (pllm_min..=pllm_max)
            .map(|m| Self::optimize_fixed_m(pllsrcclk, m, target))
            .min_by_key(|(_, _, error)| *error)
            .expect("no suitable I2S PLL configuration found");
        Self::apply_config(config);
        pll
    }

    #[cfg(feature = "rcc_shared_m")]
    fn setup_shared_m(pllsrcclk: u32, m: Option<u32>, plli2sclk: Option<u32>) -> Self {
        // "m" is None if the main PLL is not in use.
        let Some(m) = m else {
            return Self::setup(pllsrcclk, plli2sclk);
        };
        let Some(target) = plli2sclk else {
            return Self::Unused;
        };
        let (pll, config, _) = Self::optimize_fixed_m(pllsrcclk, m, target);
        Self::apply_config(config);
        pll
    }

    fn optimize_fixed_m(pllsrcclk: u32, m: u32, plli2sclk: u32) -> (Self, SingleOutputPll, u32) {
        let (config, real_plli2sclk, error) =
            SingleOutputPll::optimize(pllsrcclk, m, plli2sclk, 2, 7)
                .expect("did not find any valid I2S PLL config");
        (
            Self::Used {
                m: config.m as u32,
                plli2sclk: real_plli2sclk,
            },
            config,
            error,
        )
    }

    fn apply_config(config: SingleOutputPll) {
        let rcc = unsafe { &*RCC::ptr() };
        // "M" may have been written before, but the value is identical.
        #[cfg(feature = "rcc_shared_m")]
        rcc.pllcfgr()
            .modify(|_, w| unsafe { w.pllm().bits(config.m) });
        rcc.plli2scfgr().modify(|_, w| unsafe {
            #[cfg(not(feature = "rcc_shared_m"))]
            w.plli2sm().bits(config.m);
            w.plli2sn().bits(config.n);
            w.plli2sr().bits(config.outdiv)
        });
    }
}

#[cfg(feature = "sai")]
#[cfg(not(feature = "gpio-f413"))]
#[derive(Clone, Copy)]
pub enum SaiPll {
    Used {
        /// SAI clock (PLL output divided by the SAI clock divider).
        sai_clk: u32,
    },
    Unused,
}

#[cfg(feature = "sai")]
#[cfg(not(feature = "gpio-f413"))]
impl SaiPll {
    fn use_pll(&self) -> bool {
        matches!(self, Self::Used { .. })
    }

    fn sai_clk(&self) -> Option<u32> {
        if let Self::Used { sai_clk } = self {
            Some(*sai_clk)
        } else {
            None
        }
    }

    fn setup(pllsrcclk: u32, sai_clk: Option<u32>) -> SaiPll {
        let Some(target) = sai_clk else {
            return Self::Unused;
        };
        // Input divisor from PLL source clock, must result to frequency in
        // the range from 1 to 2 MHz
        let pllm_min = (pllsrcclk + 1_999_999) / 2_000_000;
        let pllm_max = pllsrcclk / 1_000_000;
        let (pll, config, saidiv, _) = (pllm_min..=pllm_max)
            .map(|m| Self::optimize_fixed_m(pllsrcclk, m, target))
            .min_by_key(|(_, _, _, error)| *error)
            .expect("no suitable SAI PLL configuration found");
        Self::apply_config(config, saidiv);
        pll
    }

    #[cfg(feature = "rcc_shared_m")]
    fn setup_shared_m(pllsrcclk: u32, m: Option<u32>, sai_clk: Option<u32>) -> Self {
        // "m" is None if both other PLLs are not in use.
        let Some(m) = m else {
            return Self::setup(pllsrcclk, sai_clk);
        };
        let Some(target) = sai_clk else {
            return Self::Unused;
        };
        let (pll, config, saidiv, _) = Self::optimize_fixed_m(pllsrcclk, m, target);
        Self::apply_config(config, saidiv);
        pll
    }

    fn optimize_fixed_m(
        pllsrcclk: u32,
        m: u32,
        sai_clk: u32,
    ) -> (SaiPll, SingleOutputPll, u32, u32) {
        // NOTE: This code tests lots of configurations due to the nested loops for the two
        // dividers. A smarter approach can probably speed up the search.
        let (config, saidiv, real_sai_clk, error) = (1..=32)
            .filter_map(|saidiv| {
                let target = sai_clk * saidiv;
                let (config, real_sai_clk, error) =
                    SingleOutputPll::optimize(pllsrcclk, m, target, 2, 15)?;
                Some((config, saidiv, real_sai_clk, error))
            })
            .min_by_key(|(_, _, _, error)| *error)
            .expect("no suitable I2S PLL configuration found");
        (
            Self::Used {
                sai_clk: real_sai_clk,
            },
            config,
            saidiv,
            error,
        )
    }

    fn apply_config(config: SingleOutputPll, saidiv: u32) {
        let rcc = unsafe { &*RCC::ptr() };
        rcc.dckcfgr()
            .modify(|_, w| w.pllsaidivq().set(saidiv as u8 - 1));
        // "M" may have been written before, but the value is identical.
        #[cfg(feature = "rcc_shared_m")]
        rcc.pllcfgr()
            .modify(|_, w| unsafe { w.pllm().bits(config.m) });
        rcc.pllsaicfgr().modify(|_, w| unsafe {
            #[cfg(not(feature = "rcc_shared_m"))]
            w.pllsaim().bits(config.m);
            w.pllsain().bits(config.n);
            w.pllsaiq().bits(config.outdiv)
        });
    }
}

#[cfg(not(feature = "gpio-f410"))]
struct SingleOutputPll {
    m: u8,
    n: u16,
    outdiv: u8,
}

#[cfg(not(feature = "gpio-f410"))]
impl SingleOutputPll {
    fn optimize(
        pllsrcclk: u32,
        m: u32,
        target: u32,
        min_div: u32,
        max_div: u32,
    ) -> Option<(SingleOutputPll, u32, u32)> {
        let vco_in = pllsrcclk / m;

        // We loop through the possible divider values to find the best configuration. Looping
        // through all possible "N" values would result in more iterations.
        let (n, outdiv, output, error) = (min_div..=max_div)
            .filter_map(|outdiv| {
                let target_vco_out = match target.checked_mul(outdiv) {
                    Some(x) => x,
                    None => return None,
                };
                let n = (target_vco_out + (vco_in >> 1)) / vco_in;
                let vco_out = vco_in * n;
                if !(100_000_000..=432_000_000).contains(&vco_out) {
                    return None;
                }
                let output = vco_out / outdiv;
                let error = (output as i32 - target as i32).unsigned_abs();
                Some((n, outdiv, output, error))
            })
            .min_by_key(|(_, _, _, error)| *error)?;
        Some((
            SingleOutputPll {
                m: m as u8,
                n: n as u16,
                outdiv: outdiv as u8,
            },
            output,
            error,
        ))
    }
}
